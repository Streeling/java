= Adnotări

NOTE: Acest text reprezintă, în mare măsură, traducerea documentației oficiale de la adresa
https://docs.oracle.com/javase/tutorial/java/annotations/index.html.

[quote, Socrate]
____
Eu știu că nu știu nimic
____

Adnotările reprezintă o formă de metadate. Ele sunt utilizate pentru a furniza date despre program dar nu sunt parte a
programului propriu-zis.

Pare a fi o definiție (explicație) recursivă sau foarte vaga. Nu e nimic, in continuare venim cu exemple si explicații.

== Formatul unei adnotări

Un exemplu simplu de adnotare:

[source, java]
----
@Entity
----

Simbolul „A rond” (@, în engleză „At sign”) indică compilatorul că ceea ce urmează e o adnotare. În următorul exemplu,
numele adnotării este `Override`:

[source, java]
----
@Override
void mySuperMethod() { ... }
----

Adnotările pot conține elemente, aceste elemente posedă nume și pot primi diferite valori (putem face analogie cu
parametrii unei metode):

[source, java]
----
@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass() { ... }
----

sau

[source, java]
----
@SuppressWarnings(value = "unchecked")
void myMethod() { ... }
----

În cazul când adnotarea conține un singur element si numele acestuia e `value`, putem omite numele:

[source, java]
----
@SuppressWarnings("unchecked")
void myMethod() { ... }
----

Dacă adnotarea nu are alemente, atunci parantezele (rotunde) pot fi omise, așa cum e exemplificat mai sus pentru
`@Override`.

Putem folosi mai multe adnotări pentru aceeași declarație:

[source, java]
----
@Author(name = "Jane Doe")
@EBook
class MyClass { ... }
----

Daca adnotările au același tip, atunci spunem ca avem adnotări care se repetă (în engleză „repeating annotations”):

[source, java]
----
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
----

Adnotările care se repeta sunt „suportate” începând cu Java SE 8.

Adnotările `Override` și `SuppressWarnings`, din exemplele de mau sus, sunt adnotări predefinite din Java (SE) și le
puteți găsi în pachetul `java.lang`. Mai general, orice adnotare predefinită Java este definită fie în `java.lang`, fie
în pachetul `java.lang.annotation` din Java SE API.

E posibil să definim și propriile tipuri de adnotări. Cum ar fi adnotările `Author` și `EBook` din exemplele
precedente.

== Unde putem folosi adnotările

Adnotările pot fi aplicate la declarații: declarații de clase, câmpuri, metode și de alte elemente de program. Când sunt utilizate
la declarări, convenția e să punem fiecare adnotare pe linie proprie.

Începând cu Java SE adnotările pot fi aplicate la _utilizarea_ tipurilor. De exemplu:

- Expresia ce creeaza o instanță a unei clase:
[source, java]
----
new @Interned MyObject();
----

- Conversie de tip (în engleză _type cast_):
[source, java]
----
myString = (@NonNull String) str;
----

- clauza `implements`:
[source, java]
----
class UnmodifiableList<T> implements
    @Readonly List<@Readonly T> { ... }
----

- declararea excepțiilor (clauza `throws`)
[source, java]
----
void monitorTemperature() throws
    @Critical TemperatureException { ... }
----

Acest fel de adnotări se numesc adnotări de tip (în engleză _type annotations_).

==Adnotări predefinite

===Tipuri de adnotări folosite de limbajul Java

@Deprecated:: această adnotare indică că elementul marcat este “depășit” și nu mai este recomandat de a fi utilizat.
Compilatorul generează un _warning_ atunci când este folosita o metodă, clasă sau câmp ce are adnotarea @Deprecated.
Când un element este _depășit__”__ ar trebui să fie și documentat cu tag-ul javadoc @deprecated așa cum e aratat în
urmatorul exemplu.

[source, java]
----
    // Javadoc comment follows
    /**
     * @deprecated
     * explanation of why it was deprecated
     */
    @Deprecated
    static void deprecatedMethod() { }
}
----

@Override:: informează compilatorul că elementul are drept scop să suprascrie un alt element din clasa părinte.

[source, java]
----
// mark method as a superclass method
// that has been overridden
@Override
int overriddenMethod() { }
----

Cu toate că această adnotare nu este obligatorie atunci când suprascrie, ea ne ajută să prevenim erorile. Deoarece
dacă o metoda marcată cu `@Override` eșuaiaza să suprascrie corect metodă din clasa părinte, compilatorul va genera un
mesaj de eroare.

@SuppressWarnings:: spune compilatotului sa suprime warnig-uri specifice pe care fără acesst adnotare le-ar fi
gegnerat. În exemplul urmator e folosită o metoda _depășită_ și compilatorul în mod obișnuit ar fi generat mesaj, dar
această adnotarea face ca mesajul să fie suprimat:

[source, java]
----
// use a deprecated method and tell
// compiler not to generate a warning
@SuppressWarnings("deprecation")
void useDeprecatedMethod() {
    // deprecation warning
    // - suppressed
    objectOne.deprecatedMethod();
}
----

Orice warning face parte dintr-o anumită categorie. Specifcațiile limbajului Java conține doua categorii: deprecation
și uncecked. Warning-ul uncecked poate aparea atunci când interfacing cu cod vechi înainte de advencing of generics.
Pentru a suprima mai multe categorii de warnig-uri folosiți sintaxa:

[source, java]
----
@SuppressWarnings({"unchecked", "deprecation"})
----

@SafeVarargs:: adnotarea https://docs.oracle.com/javase/8/docs/api/java/lang/SafeVarargs.html[@SafeVarargs] dacă este
aplicată la o metodă sau un constructor aserteaza ca nu vor fi efectuate operații unsafe cu parametrul său de tip
`varagrs`.

@FunctionalInterface:: adnotarea
https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html[@FunctionalInterface] a aparut în Java SE
8 și denotă ca declarația curentă de interfață are intentia de a fi interfață funcțională asa cum e definit în
specificațiile limbajului Java.
